c
exit
aggregate_children(node)
exit
aggregate_children(node)
q
aggregate_children(node)
exit
aggregate_children(node)
exit
aggregate_children(node)
exit
aggregate_children(node)
exit
aggregate_children(cur)
aggregate_children(node)
exit
cur.children.values.map(&:word)
node.children.values.map(&:word)
exit
cur.children.values.map(&:value)
cur.children.values
cur.children
cur.children.map(&:value)
exit
tr.root.find("t").find("e").find("a")
exit
exitn
tr.root.find("t").find("e").find("a").find("x")
tr.root.find("t").find("e").find("a")
tr.root.find("t").find("e").children.map(&:value)
tr.root.find("t").find("e")
tr.root.find("t").children.map(&:value)
tr.root.find("t")
tr.root.find("t)"
tr.root.children.map(&:value)
tr.root.children
tr.root
exit
tr.root
c
cur
c
cur
c
cur
exit
root
exit
new([])
new()
new
@root
root
exit
Node.new("xxx")
@root
cur
exit
Node.new("xxx")
@root
root
cur
continue
exit
n
exit
@root
root
cur
exit
exception
n
c
arr[0..k_index]
arr
n
arr
exit
arr
exit
arr
n
arr
exit
c
arr
c
current
c
arr
c
arr
c
exit
n
wall
arr
n
wall
current
arr
n
arr
arr[current]
right
current
c
arr
right
current
c
current
arr
c
arr
c
arr
c
wall
current
arr
c
wall
current
arr
c
exit
arr
c
arr
exit
arr
swap(arr, 0, wall)
arr
arr[current] <= arr[pivot]
pivot
left
current
exit
arr
c
arr
c
exit
arr
c
arr
exit
arr
c
exit
arr
c
arr
arr[right]
right
left
c
arr
c
arr
c
arr
c
arr
exit
pivot
arr
c
arr
c
arr
c
exit
pivot
wall
arr
n
arr[cur] < arr[pivot]
s
pivot
cur
n
exit
arr
c
arr[right]
left
keft
arr
exit
arr
right
left
c
arr
c
arr
arrr
c
exit
arr
c
arr
c
k < pivot
arr
pivot
c
arr
exit
arr
c
exit
arr
c
k
pivot
arr
arr[pivot]
pivot
n
arr
n
pivot
cur
n
left == right
c
arr
left == right
c
arr[right]
arr
arr[pivot + 1]
pivot + 1
s
k < pivot
pivot
c
right
left
c
exit
wall - 1
pivot - 1
wall + 2
pivot + 1
k < pivot
arr[pivot]
arr
k
pivot
c
exit
